# Newsletter Services Lambda Implementation Notes

**Date:** 2025-10-22
**Generated by:** Claude Code

## Overview

This document outlines the implementation of four AWS Lambda functions for the jscom-newsletter-services project. These Lambda functions follow the architectural patterns established in the jscom-contact-services project and provide a complete newsletter subscription management system.

## Lambda Functions Created

### 1. newsletter-api-public

**Location:** `/Users/john/code/websites/jscom-newsletter-services/lambdas/src/newsletter-api-public/`

**Purpose:** Public-facing API for newsletter subscription operations

**Technology Stack:**
- Python 3.13
- AWS Lambda Powertools (APIGatewayHttpResolver for routing)
- Pydantic v2 for request/response validation
- boto3 for AWS service interaction

**Endpoints:**

1. `POST /v1/newsletter` - Subscribe to newsletter
   - Request body: `{"email": "user@example.com", "name": "User Name"}`
   - Validates email format using Pydantic EmailStr
   - Extracts IP address and user agent from API Gateway v2 event context
   - Sends operation message to SQS queue for asynchronous processing
   - Returns: 200 with success message, 400 for validation errors, 500 for server errors

2. `DELETE /v1/newsletter` - Unsubscribe from newsletter
   - Request body: `{"email": "user@example.com"}`
   - Validates email format
   - Sends unsubscribe operation to SQS queue
   - Returns: 200 with success message

3. `GET /v1/newsletter/status?email=user@example.com` - Check subscription status
   - Query parameter: email (required)
   - Queries DynamoDB email-index GSI to find subscriber
   - Returns: 200 with status response containing email, status, and timestamps
   - Status values: 'active', 'inactive', or 'not_found'

**Key Design Decisions:**

- **Asynchronous Processing:** POST and DELETE operations send messages to SQS rather than directly updating DynamoDB. This decouples the public API from database operations and provides better fault tolerance.

- **Request Metadata Extraction:** The function extracts IP address and user agent from the API Gateway v2 event structure:
  ```python
  ip_address = event['requestContext']['http']['sourceIp']
  user_agent = event['requestContext']['http']['userAgent']
  ```

- **Email Validation:** Uses Pydantic's EmailStr type for robust email format validation before sending to the queue.

- **Status Endpoint Direct Query:** The GET status endpoint queries DynamoDB directly (read operation) rather than going through SQS, providing immediate feedback to users.

**Environment Variables:**
- `NEWSLETTER_OPERATIONS_QUEUE_URL` - SQS queue URL for subscription operations
- `NEWSLETTER_SUBSCRIBERS_TABLE_NAME` - DynamoDB table name for subscribers

**Dependencies (requirements.txt):**
```
boto3>=1.28.0
aws-lambda-powertools>=2.20.0
pydantic>=2.0.0
email-validator>=2.0.0
```

---

### 2. newsletter-sqs-processor

**Location:** `/Users/john/code/websites/jscom-newsletter-services/lambdas/src/newsletter-sqs-processor/`

**Purpose:** SQS-triggered worker that processes subscription operations

**Technology Stack:**
- Python 3.13
- boto3 for DynamoDB and SQS operations
- Pydantic v2 for message validation
- Standard Python logging

**Operation Processing:**

**Subscribe Operation:**
1. Query DynamoDB by email using email-index GSI
2. If subscriber exists:
   - Status is 'inactive': Reactivate by setting status='active', updating updated_at
   - Status is 'active': Only update updated_at timestamp
3. If subscriber doesn't exist:
   - Create new record with UUID, status='active', subscribed_at, updated_at

**Unsubscribe Operation:**
1. Query DynamoDB by email using email-index GSI
2. If subscriber exists:
   - Set status='inactive', update updated_at
3. If subscriber doesn't exist:
   - Log and skip (no action needed)

**Key Design Decisions:**

- **Soft Delete Pattern:** Unsubscribe operations set status='inactive' rather than deleting records. This preserves historical data and allows for easy reactivation.

- **Idempotent Operations:** Subscribe operations for already-active subscribers only update the timestamp, making the operation idempotent and safe for retries.

- **Batch Processing:** The Lambda processes multiple SQS messages in a single invocation, tracking processed and failed counts separately.

- **Error Handling:** Failed messages are logged with their receipt handles but not automatically retried. SQS visibility timeout handles retry logic.

**DynamoDB Operations:**
- Uses `query()` on email-index GSI to find existing subscribers
- Uses `update_item()` for status changes and timestamp updates
- Uses `put_item()` for creating new subscribers
- Generates UUIDs using Python's `uuid4()` for new subscriber IDs

**Environment Variables:**
- `NEWSLETTER_SUBSCRIBERS_TABLE_NAME` - DynamoDB table name

**Dependencies (requirements.txt):**
```
boto3>=1.28.0
pydantic>=2.0.0
email-validator>=2.0.0
```

---

### 3. newsletter-api-admin

**Location:** `/Users/john/code/websites/jscom-newsletter-services/lambdas/src/newsletter-api-admin/`

**Purpose:** Administrative API for managing newsletter subscribers

**Technology Stack:**
- Python 3.13
- AWS Lambda Powertools (APIGatewayHttpResolver)
- Pydantic v2 for models and validation
- boto3 for DynamoDB operations
- Modular architecture with separate models and handlers

**Project Structure:**
```
newsletter-api-admin/
├── app/
│   ├── newsletter_api_admin_lambda.py  # Main handler with routes
│   ├── models/
│   │   ├── __init__.py
│   │   ├── subscriber_models.py        # Subscriber domain model
│   │   ├── request_models.py           # Request validation models
│   │   └── response_models.py          # Response models (ApiResponse, etc.)
│   └── handlers/
│       ├── __init__.py
│       └── subscribers.py              # Business logic functions
├── test/
│   └── test_newsletter_api_admin.py
└── requirements.txt
```

**Endpoints:**

1. `GET /v1/newsletter/admin/subscribers` - List subscribers with pagination
   - Query params: limit (1-100, default 50), next_token, status (active/inactive)
   - Uses status-index GSI if status filter is provided
   - Returns: SubscriberListResponse with paginated results
   - Pagination tokens are base64-encoded DynamoDB LastEvaluatedKey

2. `GET /v1/newsletter/admin/subscribers/<id>` - Get single subscriber
   - Returns: Subscriber details or 404 if not found

3. `GET /v1/newsletter/admin/stats` - Get system statistics
   - Returns: Total subscribers, active/inactive counts, recent 24h subscriptions
   - Scans entire table (handles pagination internally)

4. `PATCH /v1/newsletter/admin/subscribers/<id>` - Update subscriber email
   - Request body: `{"email": "newemail@example.com"}`
   - Validates new email format
   - Updates email and updated_at timestamp
   - Returns: Updated subscriber or 404 if not found

5. `DELETE /v1/newsletter/admin/subscribers/<id>` - Delete subscriber
   - Hard delete (removes record from DynamoDB)
   - Returns: Success message or 404 if not found

**Key Design Decisions:**

- **Modular Architecture:** Separates concerns into models, handlers, and the main Lambda handler. This mirrors the contact-services pattern and improves maintainability.

- **Generic ApiResponse Type:** Uses Pydantic's Generic[T] to create a type-safe response wrapper that works with any data type while maintaining consistent structure.

- **GSI Usage:** Leverages the status-index GSI when filtering by status for efficient queries instead of filtering scanned results.

- **Pagination Strategy:** Encodes DynamoDB's LastEvaluatedKey as base64 JSON for use as a pagination token. This is decoded and used as ExclusiveStartKey in subsequent requests.

- **Statistics Calculation:** Performs a full table scan with pagination handling to calculate accurate statistics. This is acceptable for admin operations but should be optimized with DynamoDB Streams or scheduled aggregation for large datasets.

**Models:**

- `Subscriber` - Domain model representing a subscriber record
- `SubscriberListQueryParams` - Query parameter validation
- `UpdateSubscriberRequest` - Email update request validation
- `SubscriberListResponse` - Paginated list response
- `StatsResponse` - Statistics response
- `ApiResponse[T]` - Generic response wrapper

**Handlers:**

- `list_subscribers()` - Query/scan with pagination and filtering
- `get_subscriber_by_id()` - Retrieve single subscriber
- `update_subscriber_email()` - Update email and timestamp
- `delete_subscriber()` - Hard delete from DynamoDB
- `get_stats()` - Calculate system statistics
- `item_to_subscriber()` - Helper to convert DynamoDB items to domain models

**Environment Variables:**
- `NEWSLETTER_SUBSCRIBERS_TABLE_NAME` - DynamoDB table name

**Dependencies (requirements.txt):**
```
boto3>=1.28.0
aws-lambda-powertools>=2.20.0
pydantic>=2.0.0
email-validator>=2.0.0
```

---

### 4. newsletter-admin-authorizer

**Location:** `/Users/john/code/websites/jscom-newsletter-services/lambdas/src/newsletter-admin-authorizer/`

**Purpose:** Lambda authorizer for securing admin API endpoints

**Technology Stack:**
- Python 3.13
- Standard library only (no external dependencies)
- Simple boolean authorization response format (API Gateway v2)

**Authorization Logic:**

1. Extract x-api-key header from API Gateway v2 event
2. Compare with ADMIN_API_KEY environment variable
3. Return `{"isAuthorized": True}` for valid keys
4. Return `{"isAuthorized": False}` for invalid or missing keys

**Key Design Decisions:**

- **API Gateway v2 Format:** Uses simple boolean authorization response format suitable for HTTP API (not REST API v1).

- **Header Normalization:** API Gateway v2 normalizes headers to lowercase, so the function looks for 'x-api-key' (lowercase).

- **No External Dependencies:** Uses only Python standard library to minimize cold start time and reduce deployment package size.

- **Comprehensive Logging:** Logs authorization attempts, successes, and failures for security auditing.

- **Fail-Secure:** Returns unauthorized if the ADMIN_API_KEY environment variable is not set, preventing accidental open access.

**Security Considerations:**

- API key should be stored in AWS Secrets Manager or Systems Manager Parameter Store and referenced in Terraform
- Consider implementing rate limiting at the API Gateway level
- Monitor CloudWatch logs for repeated authorization failures
- Rotate API keys periodically

**Environment Variables:**
- `ADMIN_API_KEY` - Expected API key value for authorization

**Dependencies (requirements.txt):**
```
# No external dependencies required - uses only Python standard library
```

---

## DynamoDB Table Schema

**Table Name:** newsletter-subscribers

**Primary Key:**
- `id` (String, UUID) - Hash key

**Attributes:**
- `email` (String) - Subscriber email address
- `name` (String) - Subscriber name
- `status` (String) - 'active' or 'inactive'
- `subscribed_at` (Number) - Unix timestamp
- `updated_at` (Number) - Unix timestamp
- `ip_address` (String) - IP from subscription request
- `user_agent` (String) - User agent from subscription request

**Global Secondary Indexes:**

1. **email-index**
   - Hash key: `email` (String)
   - Purpose: Query subscribers by email address
   - Used by: newsletter-api-public (status check), newsletter-sqs-processor (find existing)
   - Projection: ALL

2. **status-index**
   - Hash key: `status` (String)
   - Purpose: Query subscribers by status (active/inactive)
   - Used by: newsletter-api-admin (list with status filter)
   - Projection: ALL

---

## Architecture Flow

### Subscription Flow:

1. User submits email via POST to newsletter-api-public
2. API validates email format and extracts metadata
3. Message sent to SQS newsletter-operations-queue
4. newsletter-sqs-processor triggered by SQS event
5. Processor queries DynamoDB by email
6. Record created or updated based on existing status
7. SQS message acknowledged

### Unsubscription Flow:

1. User submits email via DELETE to newsletter-api-public
2. API validates email format
3. Unsubscribe message sent to SQS
4. newsletter-sqs-processor triggered by SQS event
5. Processor queries DynamoDB by email
6. Status updated to 'inactive' if found
7. SQS message acknowledged

### Admin Management Flow:

1. Admin request to newsletter-api-admin with x-api-key header
2. newsletter-admin-authorizer validates API key
3. If authorized, admin endpoint processes request
4. DynamoDB operations performed (read, update, or delete)
5. Response returned to admin

---

## Testing Strategy

Each Lambda function includes a test file with scaffolded test cases:

- **newsletter-api-public:** Tests for each endpoint, validation, metadata extraction
- **newsletter-sqs-processor:** Tests for subscribe/unsubscribe operations, edge cases, batch processing
- **newsletter-api-admin:** Tests for all admin endpoints, pagination, error handling
- **newsletter-admin-authorizer:** Tests for valid/invalid/missing keys, logging

Test implementation using pytest and moto (for AWS service mocking) is recommended.

---

## Deployment Notes

### Terraform Configuration Required:

1. **DynamoDB Table:**
   - Create newsletter-subscribers table with email-index and status-index GSIs
   - Configure appropriate read/write capacity or on-demand mode

2. **SQS Queue:**
   - Create newsletter-operations-queue
   - Configure visibility timeout (recommended: 60 seconds)
   - Configure dead-letter queue for failed messages

3. **Lambda Functions:**
   - Runtime: Python 3.13 (or python3.13 in Terraform)
   - Use `build_in_docker = true` for Lambda modules
   - Configure appropriate memory (recommended: 256MB for API functions, 512MB for processor)
   - Configure appropriate timeout (recommended: 10s for API functions, 60s for processor)

4. **API Gateway:**
   - Create HTTP API (v2) routes for public and admin endpoints
   - Attach newsletter-admin-authorizer to admin routes
   - Configure CORS if needed for public endpoints

5. **Environment Variables:**
   - Set all required environment variables in Lambda configuration
   - Store ADMIN_API_KEY in Secrets Manager or SSM Parameter Store
   - Reference secrets in Terraform using data sources

6. **IAM Permissions:**
   - newsletter-api-public: SQS SendMessage, DynamoDB Query (email-index)
   - newsletter-sqs-processor: DynamoDB Query (email-index), PutItem, UpdateItem
   - newsletter-api-admin: DynamoDB full access to subscribers table
   - newsletter-admin-authorizer: No AWS service permissions needed

### Lambda Handler Configuration:

- newsletter-api-public: `newsletter_api_public_lambda.lambda_handler`
- newsletter-sqs-processor: `newsletter_sqs_processor_lambda.lambda_handler`
- newsletter-api-admin: `newsletter_api_admin_lambda.lambda_handler`
- newsletter-admin-authorizer: `newsletter_admin_authorizer_lambda.lambda_handler`

---

## Design Patterns and Best Practices

### Patterns Followed:

1. **Event-Driven Architecture:** Public API decouples from database writes using SQS
2. **Soft Delete:** Unsubscribe sets status='inactive' instead of deleting
3. **Idempotent Operations:** Subscribe is safe to retry for active users
4. **Separation of Concerns:** Admin API separates models, handlers, and routing
5. **Type Safety:** Comprehensive Pydantic models with type hints throughout
6. **Error Handling:** Consistent error responses with appropriate HTTP status codes
7. **Logging:** Structured logging using AWS Lambda Powertools Logger
8. **API Versioning:** All routes prefixed with /v1 for future compatibility

### Python Best Practices:

1. **Type Hints:** All functions have parameter and return type annotations
2. **Docstrings:** Comprehensive Google-style docstrings for all modules, classes, and functions
3. **PEP 8 Compliance:** Consistent code formatting and naming conventions
4. **Pydantic v2:** Modern data validation with native support for union types (|)
5. **Modular Design:** Code organized into logical modules with clear responsibilities
6. **Error Messages:** User-friendly error messages without exposing internal details

### Differences from Contact Services:

1. **Simpler Domain:** Newsletter subscriptions are simpler than contact messages (no consulting type, no blocking)
2. **Direct Status Query:** Public API includes a status check endpoint (contact services doesn't)
3. **Single SQS Queue:** Uses one queue for all operations (contact services uses two queues)
4. **No Email Notification:** Does not send confirmation emails (could be added in future)
5. **Hard Delete in Admin:** Admin API supports hard delete (contact services doesn't delete)

---

## Future Enhancements

### Potential Improvements:

1. **Email Confirmation:**
   - Add email verification flow with confirmation tokens
   - Store verification status in DynamoDB
   - Add newsletter-email-sender Lambda for confirmation emails

2. **Subscription Preferences:**
   - Add preference fields (frequency, topics, format)
   - Create preference management endpoints
   - Update DynamoDB schema with preference attributes

3. **Analytics:**
   - Track subscription sources and conversion rates
   - Add DynamoDB Streams to feed analytics pipeline
   - Create CloudWatch dashboards for metrics

4. **Rate Limiting:**
   - Implement per-IP rate limiting in public API
   - Use DynamoDB or ElastiCache for rate limit tracking
   - Return 429 status for exceeded limits

5. **Audit Logging:**
   - Log all admin operations to dedicated audit table
   - Include operator identity, timestamp, and changes
   - Enable CloudTrail for API Gateway requests

6. **Export Functionality:**
   - Add endpoint to export subscriber list as CSV
   - Support filtering and date ranges
   - Generate pre-signed S3 URLs for large exports

7. **Bulk Operations:**
   - Support bulk import from CSV
   - Add batch unsubscribe functionality
   - Implement admin API pagination improvements

8. **Testing:**
   - Complete unit test implementation
   - Add integration tests with LocalStack
   - Create load tests for public API

---

## References

- jscom-contact-services project: `/Users/john/code/websites/jscom-contact-services/`
- AWS Lambda Powertools Python: https://docs.powertools.aws.dev/lambda/python/
- Pydantic v2 Documentation: https://docs.pydantic.dev/
- API Gateway v2 Authorizers: https://docs.aws.amazon.com/apigateway/latest/developerguide/http-api-lambda-authorizer.html

---

**Document Status:** Complete
**Generated By:** Claude Code
**Review Date:** 2025-10-22
